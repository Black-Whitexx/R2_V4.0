Index: Core/Inc/PID.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n  ******************************************************************************\r\n  * @file           : PID.h\r\n  * @author         : 86153\r\n  * @brief          : None\r\n  * @attention      : None\r\n  * @date           : 2024/4/27\r\n  ******************************************************************************\r\n  */\r\n\r\n#ifndef R2_MASTER_V3_PID_H\r\n#define R2_MASTER_V3_PID_H\r\n#include \"stm32g4xx_hal.h\"\r\n\r\n#define M3508_CURRENT_MAX 16384\r\n#define M6020_CURRENT_MAX 30000\r\n#define M2006_CURRENT_MAX 10000\r\n\r\n/**\r\n  * @brief  PID参数结构体定义\r\n  */\r\ntypedef struct {\r\n    float target;//定义目标值\r\n    float current;//定义实际值\r\n    float err;//定义偏差值\r\n    float err_last;//定义上一个偏差值\r\n    float Kp,Ki,Kd;//定义比例、积分、微分系数\r\n    float p_out;//定义P项输出\r\n    float i_out;//定义I项输出\r\n    float d_out;//定义D项输出\r\n    float PID_total_out;//定义PID执行输出\r\n    float integral;//定义积分值\r\n    float differentiation;//定义微分值\r\n/*-----------------------积分限幅---------------------------*/\r\n    float integral_limit;//定义积分限幅值\r\n}PID_t;\r\n\r\nvoid PID_Set(PID_t *PID, float kp, float ki, float kd, float integral_limit);\r\nfloat PID_Realise(PID_t *PID, float target, float current, float max_output, float DeadZone, float ki_gain);\r\n\r\n#endif //R2_MASTER_V3_PID_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Core/Inc/PID.h b/Core/Inc/PID.h
--- a/Core/Inc/PID.h	
+++ b/Core/Inc/PID.h	
@@ -24,7 +24,7 @@
     float current;//定义实际值
     float err;//定义偏差值
     float err_last;//定义上一个偏差值
-    float Kp,Ki,Kd;//定义比例、积分、微分系数
+    float Kp,Ki,Kd,FB_Gain;//定义比例、积分、微分系数
     float p_out;//定义P项输出
     float i_out;//定义I项输出
     float d_out;//定义D项输出
@@ -33,9 +33,12 @@
     float differentiation;//定义微分值
 /*-----------------------积分限幅---------------------------*/
     float integral_limit;//定义积分限幅值
+    float FB_Now;
+    float FB_Last;
+    float FB_Error;
 }PID_t;
 
-void PID_Set(PID_t *PID, float kp, float ki, float kd, float integral_limit);
+void PID_Set(PID_t *PID, float kp, float ki, float kd, float integral_limit,float FB_Gain);
 float PID_Realise(PID_t *PID, float target, float current, float max_output, float DeadZone, float ki_gain);
 
 #endif //R2_MASTER_V3_PID_H
Index: Core/Src/app_freertos.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* USER CODE BEGIN Header */\r\n/**\r\n  ******************************************************************************\r\n  * File Name          : app_freertos.c\r\n  * Description        : Code for freertos applications\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * Copyright (c) 2024 STMicroelectronics.\r\n  * All rights reserved.\r\n  *\r\n  * This software is licensed under terms that can be found in the LICENSE file\r\n  * in the root directory of this software component.\r\n  * If no LICENSE file comes with this software, it is provided AS-IS.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n/* USER CODE END Header */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"FreeRTOS.h\"\r\n#include \"task.h\"\r\n#include \"main.h\"\r\n#include \"cmsis_os.h\"\r\n\r\n/* Private includes ----------------------------------------------------------*/\r\n/* USER CODE BEGIN Includes */\r\n#include \"fdcan.h\"\r\n#include \"gpio.h\"\r\n#include \"DT35.h\"\r\n#include \"queue.h\"\r\n#include \"Screen.h\"\r\n/* USER CODE END Includes */\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n/* USER CODE BEGIN PTD */\r\n\r\n/* USER CODE END PTD */\r\n\r\n/* Private define ------------------------------------------------------------*/\r\n/* USER CODE BEGIN PD */\r\n\r\n/* USER CODE END PD */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n/* USER CODE BEGIN PM */\r\n\r\n/* USER CODE END PM */\r\n\r\n/* Private variables ---------------------------------------------------------*/\r\n/* USER CODE BEGIN Variables */\r\nuint8_t str_flag;\r\nextern int16_t Wheels_VelOut[0];\r\nPointStruct Target_Point;\r\nextern int16_t Toggle_Pos;\r\nextern int16_t Slope_Pos;\r\nint32_t VESC_Speed = 0;\r\nuint8_t Sheild_Flag = 0;//屏蔽控制权交给chassis任务\r\nextern float DT35_Area2;\r\nfloat LiDar_x_last,LiDar_y_last = 0;\r\nfloat Locator_Start[2];\r\nfloat MutiPos_x;\r\nfloat MutiPos_y;\r\nfloat Locator_Addup[2];\r\nfloat offset_angle = 0;\r\n\r\nuint8_t Camp = RED;\r\n\r\n//extern locater_def locater;\r\nPointStruct Start_Point = {.x = 2.68f, .y = 9.62f, .angle = 0.0f};//3区调试用�????????????\r\nPointStruct Watch_Point = {.x = 4.03f, .y = 9.62f, .angle = 0.0f};//3区调试用�????????????\r\n//定义环类型，用于�????�取不同数据作为反馈�??????????????????-\r\n\r\n/* USER CODE END Variables */\r\nosThreadId Debug_TaskHandle;\r\nosThreadId NRF_TaskHandle;\r\nosThreadId ChassisTaskHandle;\r\nosThreadId ClawTaskHandle;\r\nosThreadId SuctionTaskHandle;\r\nosThreadId VisionComTaskHandle;\r\nosThreadId CloseLoopTaskHandle;\r\nosMessageQId NRF_RX_QueueHandle;\r\nosMessageQId VisionData_QueueHandle;\r\nosMessageQId ControlQueueHandle;\r\n\r\n/* Private function prototypes -----------------------------------------------*/\r\n/* USER CODE BEGIN FunctionPrototypes */\r\n\r\n/* USER CODE END FunctionPrototypes */\r\n\r\nvoid DebugTask(void const * argument);\r\nvoid NRFTask(void const * argument);\r\nvoid chassis(void const * argument);\r\nvoid claw(void const * argument);\r\nvoid suction(void const * argument);\r\nvoid visioncom(void const * argument);\r\nvoid closeloop(void const * argument);\r\n\r\nvoid MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) */\r\n\r\n/**\r\n  * @brief  FreeRTOS initialization\r\n  * @param  None\r\n  * @retval None\r\n  */\r\nvoid MX_FREERTOS_Init(void) {\r\n  /* USER CODE BEGIN Init */\r\n\r\n  /* USER CODE END Init */\r\n\r\n  /* USER CODE BEGIN RTOS_MUTEX */\r\n    /* add mutexes, ... */\r\n  /* USER CODE END RTOS_MUTEX */\r\n\r\n  /* USER CODE BEGIN RTOS_SEMAPHORES */\r\n    /* add semaphores, ... */\r\n  /* USER CODE END RTOS_SEMAPHORES */\r\n\r\n  /* USER CODE BEGIN RTOS_TIMERS */\r\n    /* start timers, add new ones, ... */\r\n  /* USER CODE END RTOS_TIMERS */\r\n\r\n  /* Create the queue(s) */\r\n  /* definition and creation of NRF_RX_Queue */\r\n  osMessageQDef(NRF_RX_Queue, 1, RemoteRXSturct);\r\n  NRF_RX_QueueHandle = osMessageCreate(osMessageQ(NRF_RX_Queue), NULL);\r\n\r\n  /* definition and creation of VisionData_Queue */\r\n  osMessageQDef(VisionData_Queue, 1, VisionStruct);\r\n  VisionData_QueueHandle = osMessageCreate(osMessageQ(VisionData_Queue), NULL);\r\n\r\n  /* definition and creation of ControlQueue */\r\n  osMessageQDef(ControlQueue, 8, ControlMsgStruct);\r\n  ControlQueueHandle = osMessageCreate(osMessageQ(ControlQueue), NULL);\r\n\r\n  /* USER CODE BEGIN RTOS_QUEUES */\r\n    /* add queues, ... */\r\n  /* USER CODE END RTOS_QUEUES */\r\n\r\n  /* Create the thread(s) */\r\n  /* definition and creation of Debug_Task */\r\n  osThreadDef(Debug_Task, DebugTask, osPriorityNormal, 0, 1024);\r\n  Debug_TaskHandle = osThreadCreate(osThread(Debug_Task), NULL);\r\n\r\n  /* definition and creation of NRF_Task */\r\n  osThreadDef(NRF_Task, NRFTask, osPriorityNormal, 0, 1024);\r\n  NRF_TaskHandle = osThreadCreate(osThread(NRF_Task), NULL);\r\n\r\n  /* definition and creation of ChassisTask */\r\n  osThreadDef(ChassisTask, chassis, osPriorityNormal, 0, 2048);\r\n  ChassisTaskHandle = osThreadCreate(osThread(ChassisTask), NULL);\r\n\r\n  /* definition and creation of ClawTask */\r\n  osThreadDef(ClawTask, claw, osPriorityNormal, 0, 2048);\r\n  ClawTaskHandle = osThreadCreate(osThread(ClawTask), NULL);\r\n\r\n  /* definition and creation of SuctionTask */\r\n  osThreadDef(SuctionTask, suction, osPriorityNormal, 0, 2048);\r\n  SuctionTaskHandle = osThreadCreate(osThread(SuctionTask), NULL);\r\n\r\n  /* definition and creation of VisionComTask */\r\n  osThreadDef(VisionComTask, visioncom, osPriorityNormal, 0, 2048);\r\n  VisionComTaskHandle = osThreadCreate(osThread(VisionComTask), NULL);\r\n\r\n  /* definition and creation of CloseLoopTask */\r\n  osThreadDef(CloseLoopTask, closeloop, osPriorityNormal, 0, 2048);\r\n  CloseLoopTaskHandle = osThreadCreate(osThread(CloseLoopTask), NULL);\r\n\r\n  /* USER CODE BEGIN RTOS_THREADS */\r\n    /* add threads, ... */\r\n\r\n  /* USER CODE END RTOS_THREADS */\r\n\r\n}\r\n\r\n/* USER CODE BEGIN Header_DebugTask */\r\n/**\r\n  * @brief  此任务用于一些参数和外设的初始化以及使用串口和LED调试\r\n  * @param  argument: Not used\r\n  * @retval None\r\n  */\r\n/* USER CODE END Header_DebugTask */\r\nvoid DebugTask(void const * argument)\r\n{\r\n  /* USER CODE BEGIN DebugTask */\r\n    /** 等待NRF校准 **/\r\n    //包含部分初始化内�??????????????\r\n//    while (NRF24L01_Check()) {\r\n//        printf(\"no\\n\");\r\n//    }\r\n    //NRF24L01_RX_Mode();\r\n    PID_Set(&Wheels[0], 7.2f, 0.1f, 1.0f, 10000);\r\n    PID_Set(&Wheels[1], 7.2f, 0.1f, 1.0f, 10000);\r\n    PID_Set(&Wheels[2], 7.2f, 0.1f, 1.0f, 10000);\r\n    PID_Set(&Wheels[3], 7.2f, 0.1f, 1.0f, 10000);\r\n\r\n    PID_Set(&Slope_Speed_t, 4.7f, 0.08f, 0.2f, 10000);\r\n    PID_Set(&Slope_Position_t, 2.2f, 0, 0.0f, 0);\r\n    PID_Set(&Toggle_Speed_t, 7.2f, 0.5f, 2.0f, 10000);\r\n    PID_Set(&Toggle_Position_t, 0.8f, 0, 0.8f, 0);\r\n\r\n    PID_Set(&Translation_PID, 1.80f, 0.0f, 0.8f, 0.0f);\r\n    PID_Set(&Turn_PID, 0.035f, 0.0f, 0.2f, 0.0f);\r\n\r\n    PID_Set(&VisionRun1, 2.1f, 0.000f, 0.f, 0.0f);//激进PID\r\n    PID_Set(&VisionRun2, 1.5f, 0.0000f, 0.f, 0.0f);//保守PID\r\n    PID_Set(&DT35_Run, 0.01f, 0.0f, 0.0f, 0.0f);\r\n\r\n    PID_Set(&VisionPID_X, 0.0020f, 0.0f, 0.001f, 0.0f);\r\n    PID_Set(&Chassis_GetBall_PID, 1.05f, 0.0f, 0.3f, 0.0f);\r\n    /* Infinite loop */\r\n    for (;;) {\r\n        //printf(\"%.2f %.2f %.2f\\n\", DT35_Data.DT35_2, DT35_Data.DT35_3,DT35_Data.DT35_1);\r\n//        printf(\"%.2f %.2f \\n\", locater.pos_x, locater.pos_y);\r\n//        printf(\"%.3f %.3f\\n\", LiDar.locx, LiDar.locy);\r\n        //printf(\"%f %f\\n\",MutiPos_x,MutiPos_y);\r\n//        printf(\"%s\\n\", USART5_Buffer);\r\n        //printf(\"%f\\n\", LiDar.yaw);\r\n        //printf(\"%.2f,%.2f,%.2f,%.4f\\n\",locater.pos_x,locater.pos_y,locater.angle,locater.Tof_dis);\r\n        //printf(\"%x\",USART5_Buffer[1]);\r\n        //\r\n         //printf(\"%f %f %f\\n\",TOF_dis1,MutiPos_x,MutiPos_y);\r\n        //printf(\"%f\\n\",LiDar.yaw );\r\n        //printf(\"%f\\n\",TOF_dis1 );\r\n        osDelay(100);\r\n    }\r\n  /* USER CODE END DebugTask */\r\n}\r\n\r\n/* USER CODE BEGIN Header_NRFTask */\r\n/**\r\n* @brief 此函数用于接收遥控器的数�?????????????????????\r\n* @param argument: Not used\r\n* @retval None\r\n*/\r\n/* USER CODE END Header_NRFTask */\r\nvoid NRFTask(void const * argument)//现在是串口屏任务\r\n{\r\n  /* USER CODE BEGIN NRFTask */\r\n    /** 定义存储数据变量 **/\r\n//    static uint8_t rc_data[RX_PLOAD_WIDTH] = {0};//接收数组缓冲\r\n//    static RemoteRXSturct RemoteRX;//用于存遥控器传来的数\r\n//    uint8_t cmd;\r\n//    int16_t suctionSpeed = 0;\r\n    uint8_t Screen_Buffer;\r\n\r\n    /* Infinite loop */\r\n    for (;;) {\r\n//        if (NRF24L01_RxPacket(rc_data) == 0)  //接收遥控器数据，若收到返0，若没收到返1\r\n//        {\r\n//            /** 读取左右摇杆值，限制�?????????????????????-128~128 **/\r\n//            RemoteRX.lx = (int16_t) -(rc_data[1] - 128);\r\n//            RemoteRX.ly = (int16_t) -(rc_data[2] - 128);\r\n//            RemoteRX.rx = (int16_t) -(rc_data[3] - 128);\r\n//            RemoteRX.ry = (int16_t) -(rc_data[4] - 128);\r\n//            /** 接收遥控器按键命 **/\r\n//            RemoteRX.command = rc_data[5];\r\n//            /** 设置摇杆值的死区 **/\r\n//            if (abs(RemoteRX.rx) < 2) RemoteRX.rx = 0;\r\n//            if (abs(RemoteRX.ry) < 2) RemoteRX.ry = 0;\r\n//            if (abs(RemoteRX.lx) < 2) RemoteRX.lx = 0;\r\n//            if (abs(RemoteRX.ly) < 2) RemoteRX.ly = 0;\r\n//            /** 对遥控器进行滤波，原因是遥控器有莫名其妙的电平跳 **/\r\n//            if (RemoteRX.rx == -5) RemoteRX.rx = 0;\r\n//            if (RemoteRX.ry == -4) RemoteRX.ry = 0;\r\n//            if (RemoteRX.lx == -4) RemoteRX.lx = 0;\r\n//            if (RemoteRX.ly == -4) RemoteRX.ly = 0;\r\n//\r\n//            /**将NRF数据更新到四轮全�??????????????????变量�??????????????????**/\r\n//            SGW2Wheels((float) RemoteRX.rx * 3 / 128, (float) RemoteRX.ry * 3 / 128, (float) RemoteRX.lx * 3 / 128, 0);\r\n//            printf(\"%d\",RemoteRX.command);\r\n//            /** 对遥控器按键命令进行响应 **/\r\n//            switch (RemoteRX.command) {\r\n//                case Left_Up_Up:\r\n//                    break;\r\n//                case Left_Up:\r\n//                    printf(\"start\");\r\n//                    QueueBuffer = 0;\r\n//                    xQueueSend(VisionData_QueueHandle, &QueueBuffer, 100);\r\n//                    break;\r\n//                case Right_Up:\r\n//\r\n//                    break;\r\n//                case Right_Down:\r\n//\r\n//                    break;\r\n//                case Right_Right:\r\n//\r\n//                    break;\r\n//                case Left_Left:\r\n//\r\n//                    break;\r\n//                case Left_Right:\r\n//\r\n//                    break;\r\n//                case Right_Left:\r\n//\r\n//                    break;\r\n//                case Right_Up_Up:\r\n//                    break;\r\n//                default:\r\n//                    break;\r\n//            }\r\n//        printf(\"%d,%d\\n\",RemoteRX.command,RemoteRX.ly);/** 用于调试遥控器按 **/\r\n//            RemoteRX.command = 0; //重置命令\r\n//\r\n//        }\r\n        //printf(\"detecting\\n\");\r\n        Read_Screen_CMD(&Screen_Buffer);\r\n        if(Screen_Buffer == BLUE){\r\n            Camp = BLUE;\r\n        }\r\n        if(Screen_Buffer == RED){\r\n            Camp = RED;\r\n        }\r\n        if(Screen_Buffer == START){\r\n            uint8_t QueueBuffer;\r\n            osDelay(500);\r\n            QueueBuffer = 0;\r\n            xQueueSend(VisionData_QueueHandle, &QueueBuffer, 100);\r\n        }\r\n        LED0_Flashing;\r\n        osDelay(500);\r\n    }\r\n  /* USER CODE END NRFTask */\r\n}\r\n\r\n/* USER CODE BEGIN Header_chassis */\r\n/**\r\n* @brief Function implementing the ChassisTask thread.\r\n* @param argument: Not used\r\n* @retval None\r\n*/\r\n/* USER CODE END Header_chassis */\r\nvoid chassis(void const * argument)\r\n{\r\n  /* USER CODE BEGIN chassis */\r\n    ControlMsgStruct ControlQueueBuf;\r\n    uint8_t Stop_Flag = 1;\r\n    uint8_t CloseLoopStatus = 0;\r\n    PointStruct target_point = {0, 0, 0};\r\n    float offset_x = 0;\r\n    uint8_t QueueBuffer = 0;\r\n    uint8_t number = 0;\r\n    uint8_t AlignStatus = 0,last_cmd = 0;\r\n    VisionStruct visiondatabuf;\r\n    uint8_t StartPointNumber = 0;\r\n    /* Infinite loop */\r\n    for (;;) {\r\n        if (xQueuePeek(ControlQueueHandle, &ControlQueueBuf, 0) == pdTRUE) {\r\n            if (ControlQueueBuf.Device == CHASSIS) {\r\n                xQueueReceive(ControlQueueHandle, &ControlQueueBuf, 0);\r\n                switch (ControlQueueBuf.Command) {\r\n                    case CHASSIS_RUN:\r\n                        Stop_Flag = 0;\r\n                        break;\r\n                    case CHASSIS_STOP:\r\n                        Stop_Flag = 1;\r\n                        break;\r\n                    case CloseLoop_START:\r\n                        //printf(\"STart\");\r\n                        CloseLoopStatus = CloseLoop_START;\r\n                        target_point.x = ControlQueueBuf.data[0];\r\n                        target_point.y = ControlQueueBuf.data[1];\r\n                        target_point.angle = ControlQueueBuf.data[2];\r\n                        break;\r\n                    case CloseLoop_MID360:\r\n                        CloseLoopStatus = CloseLoop_MID360;\r\n                        target_point.x = ControlQueueBuf.data[0];\r\n                        target_point.y = ControlQueueBuf.data[1];\r\n                        target_point.angle = ControlQueueBuf.data[2];\r\n                        AlignStatus = (int) ControlQueueBuf.data[3];\r\n                        //Sheild_Flag = 1;\r\n                        break;\r\n                    case CloseLoop_Mid360AndDT35:\r\n                        CloseLoopStatus = CloseLoop_Mid360AndDT35;\r\n                        target_point.x = ControlQueueBuf.data[0];\r\n                        target_point.y = ControlQueueBuf.data[1];\r\n                        target_point.angle = ControlQueueBuf.data[2];\r\n                        number = (int) ControlQueueBuf.data[3];\r\n                        last_cmd = 0;\r\n                        break;\r\n                    case CloseLoop_DT35:\r\n                        printf(\"CLDT35_GET\");\r\n                        CloseLoopStatus = CloseLoop_DT35;\r\n                        target_point.x = ControlQueueBuf.data[0];\r\n                        target_point.y = ControlQueueBuf.data[1];\r\n                        target_point.angle = ControlQueueBuf.data[2];\r\n                        break;\r\n                    case CloseLoop_Ball:\r\n                        if(last_cmd == 0)\r\n                        {\r\n                            CloseLoopStatus = CloseLoop_Ball;\r\n                            offset_x = ControlQueueBuf.data[0];\r\n                        }\r\n                        break;\r\n//                  case CloseLoop_Left:\r\n//                      CloseLoopStatus = CloseLoop_Left;\r\n//                      offset_x = ControlQueueBuf.data[0];\r\n//                      break;\r\n//                  case CloseLoop_Right:\r\n//                      CloseLoopStatus = CloseLoop_Right;\r\n//                      offset_x = ControlQueueBuf.data[0];\r\n//                      break;\r\n                    case GoForwardSlowly:\r\n                        CloseLoopStatus = GoForwardSlowly;\r\n                        //last_cmd = 1;\r\n                        break;\r\n                    case CHASSIS_TURN:\r\n                        CloseLoopStatus = CHASSIS_TURN;\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        /** 判断程序**/\r\n        /** 这一部分是奥里给 **/\r\n        if (Stop_Flag == 1) {\r\n            Car_Stop;\r\n            //printf(\"stop\");\r\n        }\r\n        else {\r\n            if (!(target_point.x == 0 && target_point.y == 0)) {\r\n                //printf(\"in\\n\");\r\n                //printf(\"%d\",CloseLoopStatus);\r\n                if(CloseLoopStatus == CloseLoop_START){\r\n                    //printf(\"startrunning\");\r\n                    /** 纵向 **/\r\n                    if(StartPointNumber == 0) {\r\n                        //printf(\"detecting1\\n\");\r\n                        Chassis_Move_OfVision(&target_point,&VisionRun1,2.5f);\r\n                        if (fabsf(target_point.y-MutiPos_y) < 0.05f) {\r\n                            ControlMsgSet(&ControlQueueBuf, CHASSIS, CloseLoop_START, Run1to3_Points[1].x,\r\n                                          Run1to3_Points[1].y, 0, 0);\r\n                            xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                            ControlMsgSet(&ControlQueueBuf, CHASSIS, CHASSIS_RUN, 0, 0, 0, 0);\r\n                            xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                            ControlMsgInit(&ControlQueueBuf);\r\n                            StartPointNumber = 1;\r\n                            printf(\"1ok\");\r\n                        }\r\n                    }\r\n                    /** 横向 **/\r\n                    else if(StartPointNumber == 1) {\r\n                        //printf(\"%f %f\",target_point.x,target_point.y);\r\n                        Chassis_Move_OfVision(&target_point,&VisionRun1,2.5f);\r\n                            if (fabsf(target_point.x-MutiPos_x) < 0.05f ) {\r\n                                ControlMsgSet(&ControlQueueBuf, CHASSIS, CloseLoop_START, Run1to3_Points[2].x,\r\n                                              Run1to3_Points[2].y, 0, 0);\r\n                                xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                                ControlMsgSet(&ControlQueueBuf, CHASSIS, CHASSIS_RUN, 0, 0, 0, 0);\r\n                                xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                                ControlMsgInit(&ControlQueueBuf);\r\n                                StartPointNumber = 2;\r\n                                printf(\"2ok\");\r\n                            }\r\n                    }\r\n                    /**纵向 **/\r\n                    else if(StartPointNumber == 2) {\r\n                        Chassis_Move_OfVision(&target_point,&VisionRun1,2.5f);\r\n                        //printf(\"%f %f\",target_point.x,target_point.y);\r\n                        if ((target_point.y -MutiPos_y) < 0.1f &&\r\n                            fabsf(LiDar.yaw - target_point.angle) < 3) {\r\n                            ControlMsgSet(&ControlQueueBuf, CHASSIS, CloseLoop_MID360, Start_Point.x,\r\n                                          Start_Point.y, 0, 0);\r\n                            xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                            ControlMsgSet(&ControlQueueBuf, CHASSIS, CHASSIS_RUN, 0, 0, 0, 0);\r\n                            xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                            ControlMsgSet(&ControlQueueBuf, CLAW, CLAW_CLOSE, 0, 0, 0, 0);\r\n                            xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                            ControlMsgSet(&ControlQueueBuf, CLAW, Toggle_Mid, 0, 0, 0, 0);\r\n                            xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                            ControlMsgSet(&ControlQueueBuf, SUCTION, SUCTION_ON, 0, 0, 0, 0);\r\n                            xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                            ControlMsgSet(&ControlQueueBuf, SUCTION, StopVESC, 0, 0, 0, 0);\r\n                            xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                            ControlMsgSet(&ControlQueueBuf, SUCTION, Slope_OFF, 0, 0, 0, 0);\r\n                            xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                            ControlMsgInit(&ControlQueueBuf);\r\n                            StartPointNumber = 3;\r\n                            printf(\"3ok\");\r\n                        }\r\n                    }\r\n                }\r\n                if (CloseLoopStatus == CloseLoop_MID360) {\r\n                    Chassis_Move_OfVision(&target_point,&Chassis_GetBall_PID,2.5f);\r\n                    //printf(\"%f %f\\n\",MutiPos_x,MutiPos_y);\r\n                    if (Distance_Calc(target_point,MutiPos_x,MutiPos_y) < 0.3f &&\r\n                        fabsf(LiDar.yaw - target_point.angle) < 3) {\r\n                        printf(\"send1normal\\n\");\r\n                        //printf(\"%f\",LiDar.yaw );\r\n                        //Sheild_Flag = 0;\r\n                        Vision_Send(0xCC);\r\n                        ControlMsgSet(&ControlQueueBuf, CHASSIS, CHASSIS_STOP, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgInit(&ControlQueueBuf);\r\n                    }\r\n                }\r\n                else if (CloseLoopStatus == CloseLoop_Mid360AndDT35) {\r\n                    Chassis_Move_OfVision(&target_point,&VisionRun2,2.5f);\r\n                    //printf(\"MAD\");\r\n                    if (fabsf(target_point.x - LiDar.locx) < 1.f &&\r\n                        fabsf(LiDar.yaw - target_point.angle) < 3.f) {\r\n                        ControlMsgSet(&ControlQueueBuf, CHASSIS, CloseLoop_DT35, DT35_AimPoints[number - 1].x,\r\n                                      DT35_AimPoints[number - 1].y, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgInit(&ControlQueueBuf);\r\n                        printf(\"MID2DT,ok\\n\");\r\n                    }\r\n                }\r\n                else if (CloseLoopStatus == CloseLoop_DT35) {\r\n                    Chassis_Move_OfDT35(&target_point);\r\n                    //printf(\"InDT\\n\");\r\n//                    printf(\"%f %f\",DT35_Data.back,DT35_Data.Right);\r\n                    //Chassis_Move_OfDT35(&target_point);\r\n                    //printf(\"%f\\n\",Distance_Calc(target_point, DT35_Data.DT35_1, DT35_Data.DT35_2));\r\n                    if (Distance_Calc(target_point, DT35_Data.DT35_1, DT35_Data.DT35_3) < 5.0f) {\r\n                        ControlMsgSet(&ControlQueueBuf, CLAW, CLAW_OPEN, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgSet(&ControlQueueBuf, CHASSIS, CHASSIS_STOP, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        osDelay(500);\r\n                        ControlMsgSet(&ControlQueueBuf, CHASSIS, CloseLoop_MID360, Watch_Point.x, Watch_Point.y,\r\n                                      Watch_Point.angle, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgSet(&ControlQueueBuf, CHASSIS, CHASSIS_RUN, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n//                        ControlMsgSet(&ControlQueueBuf, CLAW, CLAW_CLOSE, 0, 0, 0, 0);\r\n//                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n//                        ControlMsgSet(&ControlQueueBuf, CLAW, Toggle_Mid, 0, 0, 0, 0);\r\n//                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgSet(&ControlQueueBuf, SUCTION, SUCTION_OFF, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgSet(&ControlQueueBuf, SUCTION, StopVESC, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgSet(&ControlQueueBuf, SUCTION, Slope_OFF, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        Vision_Send(0xCC);\r\n                        printf(\"DT35send1\\n\");\r\n                    }\r\n                }\r\n                    /** 对球闭环 **/\r\n                else if (CloseLoopStatus == CloseLoop_Ball) {\r\n                    if(AlignStatus == 1) {\r\n                        float Speed_xy = -PID_Realise(&VisionPID_X, 0, offset_x, 1.0f, 3,1);\r\n                        float omega = PID_Realise(&Turn_PID, 0, LiDar.yaw, 0.5f, 0.5f,1);\r\n                        float Speed_y = Speed_xy;\r\n                        SGW2Wheels(-0.1f, Speed_y, omega, 0);\r\n                        if (fabsf(offset_x) < 30) {\r\n                            ControlMsgSet(&ControlQueueBuf, CHASSIS, GoForwardSlowly, 0, 0, 0, 0);\r\n                            xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                            ControlMsgInit(&ControlQueueBuf);\r\n                        }\r\n                    }\r\n                    else if (AlignStatus == 5){\r\n                        float go_speed;\r\n                        float Speed_xy = -PID_Realise(&VisionPID_X, 0, offset_x, 1.0f, 3,1);\r\n                        float omega = PID_Realise(&Turn_PID, offset_angle, LiDar.yaw, 0.5f, 0.5f,1);\r\n                        if (fabsf(offset_x) < 15) {\r\n                            go_speed = 0.5f;\r\n                        }\r\n                        else {\r\n                            go_speed = 0.3f;\r\n                        }\r\n                        float Speed_x = -Speed_xy - go_speed;\r\n                        float Speed_y = Speed_xy;\r\n                        SGW2Wheels(Speed_x, Speed_y, omega, 0);\r\n                    }\r\n                    else if (AlignStatus == 6){\r\n                        float go_speed;\r\n                        float Speed_xy = -PID_Realise(&VisionPID_X, 0, offset_x, 1.0f, 3,1);\r\n                        float omega = PID_Realise(&Turn_PID, -offset_angle, LiDar.yaw, 0.5f, 0.5f,1);\r\n                        if (fabsf(offset_x) < 15) {\r\n                                go_speed = 0.5f;\r\n                        }\r\n                        else {\r\n                            go_speed = 0.3f;\r\n                        }\r\n                        float Speed_y = Speed_xy;\r\n                        float Speed_x = Speed_xy - go_speed;\r\n                        SGW2Wheels(Speed_x, Speed_y, omega, 0);\r\n                    }\r\n                } else if (CloseLoopStatus == GoForwardSlowly) {\r\n                    SGW2Wheels(-1.f, 0, 0, 0);\r\n                }\r\n            }\r\n        }\r\n        osDelay(1);\r\n    }\r\n  /* USER CODE END chassis */\r\n}\r\n\r\n/* USER CODE BEGIN Header_claw */\r\n/**\r\n* @brief Function implementing the ClawTask thread.\r\n* @param argument: Not used\r\n* @retval None\r\n*/\r\n/* USER CODE END Header_claw */\r\nvoid claw(void const * argument)\r\n{\r\n  /* USER CODE BEGIN claw */\r\n    ControlMsgStruct ControlQueueBuf;\r\n    /* Infinite loop */\r\n    for (;;) {\r\n        if (xQueuePeek(ControlQueueHandle, &ControlQueueBuf, 0) == pdTRUE) {\r\n            if (ControlQueueBuf.Device == CLAW) {\r\n                xQueueReceive(ControlQueueHandle, &ControlQueueBuf, 0);\r\n                switch (ControlQueueBuf.Command) {\r\n                    case CLAW_OPEN:\r\n                        HAL_GPIO_WritePin(GPIOD, GPIO_PIN_11, GPIO_PIN_SET);\r\n                        //printf(\"open\");\r\n                        break;\r\n                    case CLAW_CLOSE:\r\n                        printf(\"close\");\r\n                        HAL_GPIO_WritePin(GPIOD, GPIO_PIN_11, GPIO_PIN_RESET);\r\n                        break;\r\n                    case Toggle_Up:\r\n                        Toggle_Pos = 3100;\r\n                        break;\r\n                    case Toggle_Mid:\r\n                        Toggle_Pos = 1500;\r\n                        break;\r\n                    case Toggle_Down:\r\n                        Toggle_Pos = 100;\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        osDelay(1);\r\n    }\r\n  /* USER CODE END claw */\r\n}\r\n\r\n/* USER CODE BEGIN Header_suction */\r\n/**\r\n* @brief Function implementing the SuctionTask thread.\r\n* @param argument: Not used\r\n* @retval None\r\n*/\r\n/* USER CODE END Header_suction */\r\nvoid suction(void const * argument)\r\n{\r\n  /* USER CODE BEGIN suction */\r\n    ControlMsgStruct ControlQueueBuf;\r\n    /* Infinite loop */\r\n    for (;;) {\r\n        if (xQueuePeek(ControlQueueHandle, &ControlQueueBuf, 0) == pdTRUE) {\r\n            if (ControlQueueBuf.Device == SUCTION) {\r\n                xQueueReceive(ControlQueueHandle, &ControlQueueBuf, 0);\r\n                switch (ControlQueueBuf.Command) {\r\n                    case SUCTION_ON:\r\n                        HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET);\r\n                        break;\r\n                    case SUCTION_OFF:\r\n                        HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_RESET);\r\n                        break;\r\n                    case Slope_ON:\r\n                        Slope_Pos = 1500;\r\n                        break;\r\n                    case Slope_OFF:\r\n                        Slope_Pos = 0;\r\n                        break;\r\n                    case Slope_OUT:\r\n                        Slope_Pos = 3000;\r\n                        break;\r\n                    case OpenVESC:\r\n                        VESC_Speed = -7000;\r\n                        break;\r\n                    case StopVESC:\r\n                        VESC_Speed = 0;\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        osDelay(1);\r\n    }\r\n  /* USER CODE END suction */\r\n}\r\n\r\n/* USER CODE BEGIN Header_visioncom */\r\n/**\r\n* @brief Function implementing the VisionComTask thread.\r\n* @param argument: Not used\r\n* @retval None\r\n*/\r\n/* USER CODE END Header_visioncom */\r\nvoid visioncom(void const * argument)\r\n{\r\n  /* USER CODE BEGIN visioncom */\r\n    VisionStruct visiondata;\r\n    uint8_t status;//用于小状态切�????????????\r\n    float v_x, v_y;\r\n    ControlMsgStruct ControlQueueBuf;\r\n    /* Infinite loop */\r\n    for (;;) {\r\n        if (xQueueReceive(VisionData_QueueHandle, &visiondata, 0) == pdTRUE) {\r\n            if (Sheild_Flag == 0) {\r\n                if (visiondata.flag == 0) {\r\n                    //并不是从1�????????????3，在3区调试用\r\n                    printf(\"0\\n\");\r\n                    ControlMsgSet(&ControlQueueBuf, CHASSIS, CloseLoop_START, Run1to3_Points[0].x, Run1to3_Points[0].y,\r\n                                  0, 0);\r\n//                    ControlMsgSet(&ControlQueueBuf, CHASSIS, CloseLoop_MID360, Start_Point.x, Start_Point.y,\r\n//                                 90, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, CHASSIS, CHASSIS_RUN, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, CLAW, CLAW_CLOSE, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, CLAW, Toggle_Down, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, SUCTION, SUCTION_OFF, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, SUCTION, StopVESC, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, SUCTION, Slope_OFF, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgInit(&ControlQueueBuf);\r\n                }\r\n                    /** 跑球的点，中间区 **/\r\n                else if (visiondata.flag == 1) {\r\n                    printf(\"1\\n\");\r\n                    ControlMsgSet(&ControlQueueBuf, SUCTION, SUCTION_ON, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, CLAW, CLAW_OPEN, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, CLAW, Toggle_Mid, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    //printf(\"%f %f\",-visiondata.vision_y / 1000.0f + MutiPos_x,visiondata.vision_x / 1000.0f + MutiPos_y);\r\n                    ControlMsgSet(&ControlQueueBuf, CHASSIS, CloseLoop_MID360,\r\n                                  -visiondata.vision_y / 1000.0f + MutiPos_x,\r\n                                  visiondata.vision_x / 1000.0f + MutiPos_y, 0, 1);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, CHASSIS, CHASSIS_RUN, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, SUCTION, OpenVESC, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, SUCTION, Slope_ON, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgInit(&ControlQueueBuf);\r\n                }\r\n                    /** 跑球的点，左边区 **/\r\n                else if (visiondata.flag == 5) {\r\n                    printf(\"5\\n\");\r\n                    ControlMsgSet(&ControlQueueBuf, SUCTION, SUCTION_ON, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, CLAW, CLAW_OPEN, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, CLAW, Toggle_Down, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, CHASSIS, CloseLoop_MID360,\r\n                                  -visiondata.vision_y / 1000.0f + MutiPos_x,\r\n                                  visiondata.vision_x / 1000.0f + MutiPos_y, offset_angle, 5);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, CHASSIS, CHASSIS_RUN, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, SUCTION, OpenVESC, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, SUCTION, Slope_ON, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgInit(&ControlQueueBuf);\r\n                } else if (visiondata.flag == 6) {\r\n                    printf(\"6\\n\");\r\n                    ControlMsgSet(&ControlQueueBuf, SUCTION, SUCTION_ON, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, CLAW, CLAW_OPEN, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, CLAW, Toggle_Down, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, CHASSIS, CloseLoop_MID360,\r\n                                  -visiondata.vision_y / 1000.0f +MutiPos_x,\r\n                                  visiondata.vision_x / 1000.0f + MutiPos_y, -offset_angle, 6);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, CHASSIS, CHASSIS_RUN, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, SUCTION, OpenVESC, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, SUCTION, Slope_ON, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgInit(&ControlQueueBuf);\r\n                } else if (visiondata.flag == 2) {\r\n                    if (visiondata.vision_y == 0) {\r\n                        /** 对球 **/\r\n//                        printf(\"align\");\r\n                        ControlMsgSet(&ControlQueueBuf, CHASSIS, CloseLoop_Ball, visiondata.vision_x, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgInit(&ControlQueueBuf);\r\n//                        if(TOF_dis1 < 180.f){\r\n//                            ControlMsgSet(&ControlQueueBuf, CHASSIS, CHASSIS_STOP, 0, 0, 0, 0);\r\n//                            xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n//                            ControlMsgInit(&ControlQueueBuf);\r\n//                        }\r\n                    } else if (visiondata.vision_y == 1) {\r\n                        if(TOF_dis1 < 180.f) {\r\n                            /** 正确的球即将进入车内 **/\r\n                            printf(\"rightball\\n\");\r\n//                  ControlMsgSet(&ControlQueueBuf,CHASSIS,CloseLoop_MID360,Start_Point.x,Start_Point.y,Start_Point.angle,0);\r\n//                  xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n//                  ControlMsgSet(&ControlQueueBuf,CHASSIS,CHASSIS_RUN,0,0,0,0);\r\n//                      xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                            Vision_Send(0xDD);\r\n                            ControlMsgSet(&ControlQueueBuf, CHASSIS, CloseLoop_MID360, Watch_Point.x, Watch_Point.y,\r\n                                          Watch_Point.angle, 0);\r\n                            xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                            ControlMsgSet(&ControlQueueBuf, CHASSIS, CHASSIS_RUN, 0, 0, 0, 0);\r\n                            xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                            ControlMsgSet(&ControlQueueBuf, CLAW, CLAW_OPEN, 0, 0, 0, 0);\r\n                            xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                            ControlMsgSet(&ControlQueueBuf, SUCTION, Slope_OFF, 0, 0, 0, 0);\r\n                            xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                            ControlMsgSet(&ControlQueueBuf, CLAW, Toggle_Down, 0, 0, 0, 0);\r\n                            xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                            osDelay(50);\r\n                            ControlMsgSet(&ControlQueueBuf, SUCTION, SUCTION_OFF, 0, 0, 0, 0);\r\n                            xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                            ControlMsgSet(&ControlQueueBuf, SUCTION, StopVESC, 0, 0, 0, 0);\r\n                            xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                            ControlMsgInit(&ControlQueueBuf);\r\n                        }\r\n                    }\r\n                } else if (visiondata.flag == 3) {\r\n                    if (visiondata.vision_y == 2) {\r\n                        /** 停车把球排出�???????????? **/\r\n                        printf(\"3,2\\n\");\r\n                        ControlMsgSet(&ControlQueueBuf, CHASSIS, CHASSIS_STOP, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgSet(&ControlQueueBuf, SUCTION, StopVESC, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgSet(&ControlQueueBuf, SUCTION, SUCTION_ON, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgSet(&ControlQueueBuf, CLAW, Toggle_Mid, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgSet(&ControlQueueBuf, SUCTION, Slope_ON, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        osDelay(50);\r\n                        ControlMsgSet(&ControlQueueBuf, SUCTION, Slope_OUT, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        osDelay(100);\r\n                        ControlMsgSet(&ControlQueueBuf, SUCTION, Slope_ON, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgSet(&ControlQueueBuf, SUCTION, OpenVESC, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgSet(&ControlQueueBuf, CHASSIS, CHASSIS_RUN, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgInit(&ControlQueueBuf);\r\n                    } else if (visiondata.vision_y == 6) {\r\n                        /** 夹球 **/\r\n                        printf(\"3,6\\n\");\r\n//                      ControlMsgSet(&ControlQueueBuf,CHASSIS,CHASSIS_STOP,0,0,0,0);\r\n//                      xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n//                      ControlMsgSet(&ControlQueueBuf,SUCTION,Slope_OFF,0,0,0,0);\r\n//                      xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n//                      ControlMsgSet(&ControlQueueBuf,CLAW,Toggle_Down,0,0,0,0);\r\n//                      xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n//                      ControlMsgSet(&ControlQueueBuf,CLAW,CLAW_OPEN,0,0,0,0);\r\n//                      xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n//                      osDelay(1000);\r\n                        osDelay(200);\r\n                        ControlMsgSet(&ControlQueueBuf, SUCTION, StopVESC, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgSet(&ControlQueueBuf, CLAW, CLAW_CLOSE, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        osDelay(200);\r\n                        ControlMsgSet(&ControlQueueBuf, CLAW, Toggle_Up, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n//                      ControlMsgSet(&ControlQueueBuf,SUCTION,SUCTION_OFF,0,0,0,0);\r\n//                      xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgInit(&ControlQueueBuf);\r\n                    } else if (visiondata.vision_y == 3) {\r\n                        /** 后�??再次找球 **/\r\n//                        ControlMsgSet(&ControlQueueBuf, CHASSIS, GoForwardSlowly, 0, 0, 0, 0);\r\n//                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        printf(\"3,3\\n\");\r\n                        osDelay(1000);\r\n                        ControlMsgSet(&ControlQueueBuf, CHASSIS, CloseLoop_MID360, Watch_Point.x, Watch_Point.y,\r\n                                      Watch_Point.angle, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgSet(&ControlQueueBuf, CHASSIS, CHASSIS_RUN, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgInit(&ControlQueueBuf);\r\n                    }\r\n                    else if (visiondata.vision_y == 7) {\r\n                        /** 继续吸球 **/\r\n                        ControlMsgSet(&ControlQueueBuf, SUCTION, OpenVESC, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgSet(&ControlQueueBuf, CHASSIS, CHASSIS_RUN, 0, 0, 0, 0);\r\n                        xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                        ControlMsgInit(&ControlQueueBuf);;\r\n                    }\r\n                }\r\n                else if (visiondata.flag == 4) {\r\n                    printf(\"put\");\r\n                    ControlMsgSet(&ControlQueueBuf, CHASSIS, CloseLoop_Mid360AndDT35,\r\n                                  Frame_Points[(int) (visiondata.vision_x - 1)].x,\r\n                                  Frame_Points[(int) (visiondata.vision_x - 1)].y, 0, visiondata.vision_x);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgSet(&ControlQueueBuf, CHASSIS, CHASSIS_RUN, 0, 0, 0, 0);\r\n                    xQueueSend(ControlQueueHandle, &ControlQueueBuf, 100);\r\n                    ControlMsgInit(&ControlQueueBuf);\r\n                }\r\n            } else {\r\n                //printf(\"disabled\");\r\n            }\r\n\r\n            osDelay(1);\r\n        }\r\n    }\r\n  /* USER CODE END visioncom */\r\n}\r\n\r\n/* USER CODE BEGIN Header_closeloop */\r\n/**\r\n* @brief Function implementing the CloseLoopTask thread.\r\n* @param argument: Not used\r\n* @retval None\r\n*/\r\n/* USER CODE END Header_closeloop */\r\nvoid closeloop(void const * argument)\r\n{\r\n  /* USER CODE BEGIN closeloop */\r\n    /* Infinite loop */\r\n    for (;;) {\r\n        /** 沟槽的大疆，不能分开单独控制�?????????个ID下的4个电�????????? **/\r\n        /** 四轮闭环**/\r\n        //SGW2Wheels(0.f,0.5f,0,0);\r\n        Wheels_VelOut[0] = (int16_t) PID_Realise(&Wheels[0], -Wheels_vel[0], Motor_Info[0].speed, M3508_CURRENT_MAX, 5,1);\r\n        Wheels_VelOut[1] = (int16_t) PID_Realise(&Wheels[1], -Wheels_vel[1], Motor_Info[1].speed, M3508_CURRENT_MAX, 5,1);\r\n        Wheels_VelOut[2] = (int16_t) PID_Realise(&Wheels[2], -Wheels_vel[2], Motor_Info[2].speed, M3508_CURRENT_MAX, 5,1);\r\n        Wheels_VelOut[3] = (int16_t) PID_Realise(&Wheels[3], -Wheels_vel[3], Motor_Info[3].speed, M3508_CURRENT_MAX, 5,1);\r\n        Set_Current(&hfdcan1, 0x200, Wheels_VelOut[0], Wheels_VelOut[1], Wheels_VelOut[2], Wheels_VelOut[3]);\r\n        /** 夹爪和分球板闭环**/\r\n        float Slope_Position = PID_Realise(&Slope_Position_t, Slope_Pos, Motor_Info[6].actual_total_angle, 2000, 10.0f,1);\r\n        int16_t Slope_Speed = (int16_t) PID_Realise(&Slope_Speed_t, Slope_Position, Motor_Info[6].speed,\r\n                                                    M2006_CURRENT_MAX, 5,1);\r\n        float Toggle_Position = PID_Realise(&Toggle_Position_t, Toggle_Pos, Motor_Info[7].actual_total_angle, 1000,\r\n                                            5.0f,1);\r\n        int16_t Toggle_Speed = (int16_t) PID_Realise(&Toggle_Speed_t, Toggle_Position, Motor_Info[7].speed,\r\n                                                     M3508_CURRENT_MAX, 5,1);\r\n        Set_Current(&hfdcan2, 0x1FF, 0, 0, Slope_Speed, Toggle_Speed);\r\n        Vesc_SetSpeed(&hfdcan1, VESC_ID, VESC_Speed);\r\n        /** 插�?? **/\r\n        float LiDar_x = LiDar.locx;\r\n        float LiDar_y = LiDar.locy;\r\n        float Locator_x = 0.707f * (locater.pos_x/100.f - locater.pos_y/100.f);\r\n        float Locator_y = 0.707f * (locater.pos_x/100.f + locater.pos_y/100.f);\r\n//        float Locator_x = locater.pos_x/100.f;\r\n//        float Locator_y = locater.pos_y/100.f;\r\n        //printf(\"1:%.2f,%.2f\\n\",Locator_Start[0],Locator_Start[1]);\r\n        if(!((LiDar_x == LiDar_x_last) && (LiDar_y == LiDar_y_last))){\r\n            /** 该更新了 **/\r\n            /** 码盘起始重置 **/\r\n            Locator_Addup[0] = 0;\r\n            Locator_Addup[1] = 0;\r\n            Locator_Start[0] = Locator_x;\r\n            Locator_Start[1] = Locator_y;\r\n            //printf(\"2:%.2f,%.2f\\n\",Locator_Start[0],Locator_Start[1]);\r\n        }\r\n        /** 码盘插�?? **/\r\n        Locator_Addup[0] = Locator_x - Locator_Start[0];\r\n        Locator_Addup[1] = Locator_y - Locator_Start[1];\r\n        MutiPos_x = LiDar_x + Locator_Addup[0];\r\n        if(Camp == RED) {\r\n            MutiPos_y = LiDar_y + Locator_Addup[1];\r\n        }\r\n        else if(Camp == BLUE){\r\n            MutiPos_y = -(LiDar_y + Locator_Addup[1]);\r\n        }\r\n//        MutiPos_x = Locator_Addup[0];\r\n//        MutiPos_y = Locator_Addup[1];\r\n//        MutiPos_x = locater.pos_x;\r\n//        MutiPos_y = locater.pos_y;\r\n        //printf(\"%f %f\\n\",locater.pos_x,MutiPos_x);\r\n        LiDar_x_last = LiDar_x;\r\n        LiDar_y_last = LiDar_y;\r\n        osDelay(1);\r\n    }\r\n  /* USER CODE END closeloop */\r\n}\r\n\r\n/* Private application code --------------------------------------------------*/\r\n/* USER CODE BEGIN Application */\r\n\r\n/* USER CODE END Application */\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Core/Src/app_freertos.c b/Core/Src/app_freertos.c
--- a/Core/Src/app_freertos.c	
+++ b/Core/Src/app_freertos.c	
@@ -63,13 +63,13 @@
 float MutiPos_y;
 float Locator_Addup[2];
 float offset_angle = 0;
-
+extern float DT35_Forward,DT35_CloseBall;
 uint8_t Camp = RED;
 
 //extern locater_def locater;
-PointStruct Start_Point = {.x = 2.68f, .y = 9.62f, .angle = 0.0f};//3区调试用�????????????
-PointStruct Watch_Point = {.x = 4.03f, .y = 9.62f, .angle = 0.0f};//3区调试用�????????????
-//定义环类型，用于�????�取不同数据作为反馈�??????????????????-
+PointStruct Start_Point = {.x = 2.68f, .y = 9.7f, .angle = 0.0f};//3区调试用�?????????????????
+PointStruct Watch_Point = {.x = 3.15f, .y = 9.7f, .angle = 0.0f};//3区调试用�?????????????????
+//定义环类型，用于�?????????�取不同数据作为反馈�???????????????????????-
 
 /* USER CODE END Variables */
 osThreadId Debug_TaskHandle;
